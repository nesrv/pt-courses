# Агрегация и композиция


* класс-комната
* класс-стена (композиция)
* класс-мебель (агрегация)

__

* аэропорт
* терминал (композиция)
* самолеты (агрегация)


## Концепция наследования

`Наследование` - это механизм, который позволяет нам брать все свойства другого класса и применять их к нашему собственному.

`Родительский класс` - это тот, из которого производны атрибуты и функции (также называемый базовым классом). Дочерний класс относится к классу, который использует свойства другого класса (также известного как производный класс).

## Концепция композиции

`Композиция` - это тип агрегации, при котором две сущности чрезвычайно зависят друг от друга.

Это указывает на компонент взаимосвязи.

Обе сущности зависят друг от друга по составу.

Составленный объект не может существовать без другой сущности, когда существует композиция между двумя сущностями.

Давайте возьмем пример как композиции, так и агрегации, чтобы увидеть разницу между ними и точно понять и то, и другое.

```python

class ОКЛАД:
    def __init__(self, зп, премия):
        self.зп = зп
        self.премия = премия

    def годовой_оклад(self):
        return (self.зп * 12) + self.премия

# Композиция
class СОТРУДНИК:
    def __init__(self, имя, возраст, зп, премия):
        self.name = имя
        self.возраст = возраст
        self.оклад = ОКЛАД(зп, премия)  # композиция

    def полная_зп(self):
        return self.оклад.годовой_оклад()


alex = СОТРУДНИК('Alex', 25, 10000, 1500)

print(alex.полная_зп())

```

Теперь, как мы можем видеть в приведенном выше коде, мы успешно вызвали метод совершенно другого класса внутри другого класса, который не наследует класс, используя концепцию `Композиции`.


### Недостаток композиции. Переход от композиции к агрегации

Как мы видели в предыдущем фрагменте, мы создаем объект класса `Оклад` внутри класса `Сотрудник`, который не имеет к нему никакого отношения. 

Итак, извне, если мы удалим объект класса `Сотрудник`, т.е. в данном случае `alex`, то объект класса `Оклад`, т.е. ссылка `self.оклад = ОКЛАД(зп, премия)`, также будет удален, потому что он полностью зависит от класса `Сотрудник` и его объектов. 

Чтобы решить эту проблему зависимости, на помощь пришла агрегация.

Почему мы должны использовать агрегацию вместо композиции?

## Концепция агрегации 

`Агрегация` - это концепция, в которой объект одного класса может владеть другим независимым объектом другого класса или получать к нему доступ.

Это однонаправленная ассоциация, то есть односторонняя связь. 

Например, в отделе могут быть студенты, но наоборот невозможно, и, следовательно, он однонаправленный по своей природе.

При агрегировании обе записи могут сохраняться по отдельности, что означает, что завершение одной сущности не повлияет на другую сущность.


### агрегация

```python
class ОКЛАД:
    def __init__(self, зп, премия):
        self.зп = зп
        self.премия = премия

    def годовой_оклад(self):
        return (self.зп * 12) + self.премия

# Агрегация

class СОТРУДНИК:
    def __init__(self, имя, возраст, зп):
        self.name = имя
        self.возраст = возраст
        self.оклад = зп  # агрегация

    def полная_зп(self):
        return self.оклад.годовой_оклад()


зп = ОКЛАД(10000, 1500)

alex = СОТРУДНИК('Alex', 25, зп)

print(alex.полная_зп())
 
```

Из приведенного выше кода мы получим тот же результат, который получали до использования концепции композиции. 

Но разница в том, что здесь мы не создаем объект класса ЗП внутри класса `Сотрудник` , а не в том, что мы создаем объект класса `Оклад` снаружи и передаем его как параметр класса `Сотрудник`, что дает тот же результат.


В случае `Композиция` , если мы удалим объект `alex`, то объект класса `Оклад`, который мы инициализировали внутри класса `Сотрудник`, будет удален автоматически, поскольку он полностью зависит от объекта класса `Сотрудник` , поэтому это может вызвать некоторую ошибку в выходном коде.

Но в случае агрегации мы можем видеть, что мы создали совершенно два разных объекта `user` и `Оклад` и передали объект `Оклад` в качестве параметра классу `Сотрудник` , поэтому, даже если мы удалим объект `user`, объект класса `Оклад` останется тем же, и мы также можем использовать его в другом месте.

В случае `Композиция` объекты были взаимозависимы друг от друга, но при агрегировании они однонаправлены, что означает, что, поскольку `Оклад` является полностью независимым объектом, мы можем передавать `Оклад` только `user`, не наоборот.



```python
class Musician:
    def __init__(self, name, instrument):
        self.name = name
        self.instrument = instrument


    def play_instrument(self):
        return f"{self.name} is playing {self.instrument}"


class Band:
    def __init__(self, name, members):
        self.name = name
        self.members = members

    def play_music(self):
        return [member.play_instrument() for member in self.members]



john = Musician("John", "guitar")
paul = Musician("Paul", "bass")
george = Musician("George", "guitar")
ringo = Musician("Ringo", "drums")

beatles = Band("Beatles", [john, paul, george, ringo])


for music in beatles.play_music():
    print(music)

```

## Пример композиции 2
```python
class Engine:
    def start(self):
        print("Engine started")


class Car:
    def __init__(self):
        self.engine = Engine()

    def start(self):
        self.engine.start()
        print("Car started")


my_car = Car()
my_car.start()

```

## Пример композиции 3

```python
class Door:
    def open(self):
        print("Door is open")


class Alarm:
    def activate(self):
        print("Alarm is activated")


class SecuritySystem:

    def __init__(self):
        self.door = Door()
        self.alarm = Alarm()

    def arm(self):
        self.door.open()
        self.alarm.activate()
        print("Security system armed")


my_security_system = SecuritySystem()
my_security_system.arm()

```



## Абстракция


![alt text](img/abstraction.png)


![alt text](img/abstaction_2.png)


![alt text](img/abstraction_3.png)


![alt text](img/bad_example.png)

![alt text](img/Композиция_for_abstraction.png)

![alt text](img/bad_example_2.png)

![alt text](<img/Композиция and inheritance.png>)