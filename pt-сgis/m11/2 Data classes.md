### способ № 4* Через dataclass (ОО дизайн)

Также мы должны познакомиться с относительно новой идеей «быстрого» описания классов (классов данных – `Data Classes`). 

О чем здесь речь? Смотрите, довольно часто при объявлении классов в программах на `Python` приходится прописывать инициализатор, например, следующим образом:

```python
class Thing:
    def __init__(self, name, weight, price):
        self.name = name
        self.weight = weight
        self.price = price
```

То есть, передается несколько полей: `name, weight, price`, которые предполагается сохранять в объектах класса `Thing`. 
И это довольно типовая ситуация. Мало того, если создать объект этого класса и вывести его в консоль:

```python
t = Thing("Учебник по Python", 100, 1024)
print(t)
```
то увидим нечто неинформативное, вроде:

> <__main__.Thing object at 0x0000014B7D29A7D0>

Поэтому, опять же нередко, в таких классах с данными приходится прописывать магический метод `__repr__()`, например, так:

```python
    def __repr__(self):
        return f"Thing: {self.__dict__}"
```


Видите, сколько типовой писанины приходится делать для описания классов, подобных классу `Thing?`! 

И это лишь необходимый минимум. 
Представьте объем рутиной работы для описания всего лишь нескольких таких классов.

Так как программист, зачастую, существо глубоко ленивое, но творческое, уже давно предпринимались попытки автоматизировать этот процесс. 

И вот, начиная с версии Python 3.7, появилась возможность «из коробки» использовать инструмент для оптимизации объявления классов, содержащих произвольные данные, то есть,  `Data Classes`. 

Для этого, в самом простом варианте, достаточно импортировать специальный декоратор, который так и называется `dataclass`:

```python
from dataclasses import dataclass

@dataclass
class Point:
      x: int
      y: int

p1 = Point(1,2)

```

> особенность работы с dataclass
 при объявлении `Data Classes` атрибутам нельзя присваивать изменяемые объекты в качестве значений по умолчанию. 
 
 Например, следующее объявление приведет к ошибке:

```python
from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int
    #   lst: list = [] # так не работает
    lst: list = field(default_factory=list)

p1 = Point(1,2)
p1.lst.append('привет')
print(p1)

```
Тогда спрашивается, как нам определить, например, список в качестве значения по умолчанию и так, чтобы он был независимым для каждого объекта класса  

Для этого следует воспользоваться специальной функцией `field()` из модуля `dataclasses`:
и определить через нее значение по умолчанию следующим образом:

Вычисляемые свойства в `dataclass`

```python
from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int

    # вычисляемые свойства
    def __post_init__(self):
        print(self.x,self.y)
        self.length = (self.x ** 2 + self.y ** 2) ** 0.5

p1 = Point(1,2)
print(p1)

```
Результат:
> Point(x=1, y=2)

V3D(x=1, y=2, z=3)

Спрашивается, почему здесь не видно свойства length? 

В действительности, оно присутствует в объекте p1 и мы в этом легко можем убедиться:

```python
print(p1.__dict__) # увидим:

{'x': 1, 'y': 2, 'z': 3, 'length': 3.7416573867739413}
```
Но тогда почему оно не выводится функцией `repr()`? 

Дело в том, что магический метод `__repr__()` выводит только те атрибуты, которые были указаны при объявлении класса. 

Все остальные, что создаются в процессе формирования объекта, не учитываются в методе `__repr__()`. 

Как тогда выйти из этой ситуации и указать, что локальный атрибут `length` также следует отображать? 

Очень просто! Давайте укажем этот атрибут при объявлении класса с небольшим уточнением:

> length: float = field(init=False)